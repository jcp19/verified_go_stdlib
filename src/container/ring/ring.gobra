// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package ring implements operations on circular lists.

// +gobra
package ring

// A Ring is an element of a circular list, or ring.
// Rings do not have a beginning or end; a pointer to any ring element
// serves as reference to the entire ring. Empty rings are represented
// as nil Ring pointers. The zero value for a Ring is a one-element
// ring with a nil Value.
type Ring struct {
	next, prev *Ring
	Value      any // for use by client; untouched by this library
}


pred (r *Ring) Mem(ghost s set[*Ring], ghost isInit bool) {
	r in s &&
	(forall i *Ring :: i in s ==> (acc(&i.next) && acc(&i.prev) && acc(&i.Value))) &&
	((r.next == nil || r.prev == nil) ==> !isInit) && //# More correctly, it is !isInit if it cannot reach itself in both directions via the same Ring elements
	(!isInit ==> ((s == set[*Ring]{r}) && (r.next == nil && r.prev == nil))) &&
	(isInit ==> (
		(len(s)==1 ==> (r.next==r && r.prev==r)) &&
		(forall i *Ring :: i in s ==> (i.next != nil && i.prev != nil)) &&
		//((len(s) > 1) ==> (forall i *Ring :: i in s ==> (i.next != i && i.prev != i))) &&
		(forall i, j *Ring :: ((i in s && i.next == j) ==> (j in s && j.prev == i && i.next.prev == i && j.prev.next == j))) &&
		(forall i, j *Ring :: ((i in s && i.prev == j) ==> (j in s && j.next == i && i.prev.next == i && j.next.prev == j)))))
}
//# enforce structure by:
//# forall elements, forall i in [0,len]: moveLeft(i) == moveRight(len-i)
//# problematic for Ring because we get Len() by the same logic
/*
requires r.Mem(elems, isInit)
ensures  r.Mem(set[*Ring]{r}, true)
ensures  r == res
decreases
func (r *Ring) init(ghost elems set[*Ring], ghost isInit bool) (res *Ring) {
	unfold r.Mem(elems, isInit)
	r.next = r
	r.prev = r
	fold r.Mem(set[*Ring]{r}, true)
	return r
}


// Next returns the next ring element. r must not be empty.
//# We use 'owner' here to make calls from different receivers in the same ring structure work (see e.g. Link)
requires r != nil
requires r in elems
requires owner.Mem(elems, isInit)
ensures  !isInit ==> (owner.Mem(set[*Ring]{r}, true) && res == r) //# The comment does not explain that r is returned if the ring is not initialized but that's what the implementation does.
ensures  isInit ==> (owner.Mem(elems, true) && res in elems)
ensures  isInit ==> (unfolding owner.Mem(elems, true) in (res == r.next))
decreases
func (r *Ring) Next(ghost elems set[*Ring], ghost owner *Ring, ghost isInit bool) (res *Ring) {
	unfold owner.Mem(elems, isInit)
	if r.next == nil {
		//# here we know !isInit
		fold owner.Mem(elems, false)
		return r.init(elems, false)
	}
	res = r.next
	fold owner.Mem(elems, true)
}


// Prev returns the previous ring element. r must not be empty.
//# We use 'owner' here to make calls from different receivers in the same ring structure work (see e.g. Link)
requires r != nil
requires r in elems
requires owner.Mem(elems, isInit)
ensures  !isInit ==> (owner.Mem(set[*Ring]{r}, true) && res == r) //# The comment does not explain that r is returned if the ring is not initialized but that's what the implementation does.
ensures  isInit ==> (owner.Mem(elems, true) && res in elems)
ensures  isInit ==> (unfolding owner.Mem(elems, true) in (res == r.prev))
decreases
func (r *Ring) Prev(ghost elems set[*Ring], ghost owner *Ring, ghost isInit bool) (res *Ring) {
	unfold owner.Mem(elems, isInit)
	if r.next == nil {
		//# here we know !isInit
		fold owner.Mem(elems, false)
		return r.init(elems, false)
	}
	res = r.prev
	fold owner.Mem(elems, true)
}


ghost
requires owner.Mem(elems,true)
requires r in elems
requires n >= 0
ensures (n==0) ==> res==r 
ensures (n>0) ==> res==(unfolding owner.Mem(elems,true) in r.next.moveNext(n-1, owner, elems)) 
pure func (r *Ring) moveNext(n int, ghost owner *Ring, ghost elems set[*Ring]) (res * Ring){
	return unfolding owner.Mem(elems,true) in ((n==0) ? r : r.next.moveNext(n-1, owner, elems))
}*/

/*
//# TEST NEXT
requires r.Mem(elems,true)
requires r in elems
ensures  r.Mem(elems, true)
ensures  (res == r.moveNext(3, r, elems))
func (r *Ring) moveNextTest(ghost elems set[*Ring]) (res *Ring){
	unfold r.Mem(elems, true)
	res = r.next.next.next
	fold r.Mem(elems, true)
}
*/
/*------
ghost
requires owner.Mem(elems,true)
requires r in elems
requires n <= 0
ensures (n==0) ==> res==r 
ensures (n<0) ==> res==(unfolding owner.Mem(elems,true) in r.prev.movePrev(n+1, owner, elems)) 
pure func (r *Ring) movePrev(n int, ghost owner *Ring, ghost elems set[*Ring]) (res * Ring){
	return unfolding owner.Mem(elems,true) in ((n==0) ? r : r.prev.movePrev(n+1, owner, elems))
}*/

/*
//# TEST PREV
requires r.Mem(elems,true)
requires r in elems
ensures  r.Mem(elems, true)
ensures  (res == r.movePrev(-3, r, elems))
func (r *Ring) movePrevTest(ghost elems set[*Ring]) (res *Ring){
	unfold r.Mem(elems, true)
	res = r.prev.prev.prev
	fold r.Mem(elems, true)
}
*/


/*
// Move moves n % r.Len() elements backward (n < 0) or forward (n >= 0)
// in the ring and returns that ring element. r must not be empty.
requires  r.Mem(elems, isInit) //# make this PRESERVES
requires  r != nil
requires  r in elems
ensures   !isInit ==> (r.Mem(set[*Ring]{r}, true) && res == old(r)) //# The comment does not explain that r is returned if the ring is not initialized but that's what the implementation does.
ensures   (n == 0) ==> (res == r)
ensures   isInit ==> r.Mem(elems, true)
//ensures   (isInit && n>0) ==> (res == r.moveNext(n, r, elems))
//ensures   (isInit && n<0) ==> (res == r.movePrev(n, r, elems))
//# Why does the implementation not make the modulo calculation and save on potentially unnecessary iterations? --> We'd need to run Len() (Len() many iterations) but for n > 2*Len() it'd still always make sense to compute the modulus
func (r *Ring) Move(n int, ghost elems set[*Ring], ghost isInit bool) (res *Ring) {
	if unfolding r.Mem(elems, isInit) in r.next == nil {
		return r.init(elems, isInit)
		assert r.Mem(set[*Ring]{r}, true)
	}
	
    startRing := r  //# included for invariant
    startN := n     //# included for invariant
	switch {
	case n < 0:
		invariant startRing.Mem(elems, true)
		invariant r in elems
		invariant startN <= n && n <= 0
        //invariant startRing.movePrev((startN - n), startRing, elems) == r
		decreases 0 - n
		for ; n < 0; n++ {
			unfold startRing.Mem(elems, true)
			r = r.prev
			fold startRing.Mem(elems, true)
		}
	case n > 0:
		invariant startRing.Mem(elems, true)
		invariant r in elems
		invariant startN >= n && n >= 0
        //invariant startRing.moveNext((startN - n), owner, elems) == r
		decreases n
		for ; n > 0; n-- {
			unfold startRing.Mem(elems, true)
			r = r.next
			fold startRing.Mem(elems, true)
		}
	}
	return r
}*/

// New creates a ring of n elements.
ensures n <= 0 ==> res == nil
//ensures n > 0 ==> (len(elems) == n && res.Mem(elems, true))
func New(n int) (res *Ring, ghost elems set[*Ring]) {
	if n <= 0 {
		res = nil
		elems = set[*Ring]{}
		return
	}
	r := new(Ring)
	p := r

	var q *Ring = p //testing

	elems = set[*Ring]{r}

	invariant (1 <= i && i <= n)
	invariant r in elems
	invariant p in elems
	invariant q in elems
	invariant (forall e *Ring :: e in elems ==> (acc(&e.next) && acc(&e.prev) && acc(&e.Value)))
	
	invariant r != p ==> (q != p && q.next != nil && q.next == p && p.prev == q)

	invariant r != p ==> p.prev != nil
	invariant forall e *Ring :: e in elems ==> ((e != r && e != p) ==> (e.next != nil && e.prev != nil))
	invariant forall e, s *Ring :: (e in elems && e.next == s && e != p && s != r) ==> (s in elems && s.prev == e && e.next.prev == e && s.prev.next == s)
	//invariant forall e, s *Ring :: (e in elems && e.prev == s && e != r && s != p) ==> (s in elems && s.next == e /*&& e.prev.next == e && s.next.prev == s*/)
	//invariant forall e, s *Ring :: (e in elems && e.prev == s && e != r && s != p) ==> (s in elems && s.next == e) //# Why does this not work?
	decreases n-i
	for i := 1; i < n; i++ {
		p.next = &Ring{prev: p}
		
		q = p //testing
		p = p.next
		elems = elems union set[*Ring]{p}
	}

	//unfold r.Mem(elems, false)
	p.next = r
	r.prev = p
	//assert forall e, s *Ring :: (e in elems && e.next == s && e != p && s != r) ==> (s in elems && s.prev == e && e.next.prev == e && s.prev.next == s)
	assert p in elems
	assert r in elems
	assert p.next == r
	assert r.prev == p
	assert r.prev.next == r
	assert p.next.prev == p
	//assert forall e, s *Ring :: (e in elems && e.next == s && e == p && s == r) ==> (s in elems && s.prev == e && e.next.prev == e && s.prev.next == s)
	//assert forall e, s *Ring :: (e in elems && e.next == s && e == p && s != r) ==> (s in elems && s.prev == e && e.next.prev == e && s.prev.next == s)
	//assert forall e, s *Ring :: (e in elems && e.next == s && s == r) ==> (s in elems && s.prev == e && e.next.prev == e && s.prev.next == s)
	//assert forall e, s *Ring :: (e in elems && e.next == s && s != r) ==> (s in elems && s.prev == e && e.next.prev == e && s.prev.next == s)
	//assert forall e, s *Ring :: (e in elems && e.next == s && e == p) ==> (s in elems && s.prev == e && e.next.prev == e && s.prev.next == s)
	//assert forall e, s *Ring :: (e in elems && e.next == s) ==> (s in elems && s.prev == e && e.next.prev == e && s.prev.next == s)

	
	assert forall e *Ring :: e in elems ==> (e.next != nil && e.prev != nil)

	res = r
}

/*
// New creates a ring of n elements.
ensures n <= 0 ==> res == nil
ensures n > 0 ==> (len(elems) == n && res.Mem(elems, true))
func New(n int) (res *Ring, ghost elems set[*Ring]) {
	if n <= 0 {
		res = nil
		elems = set[*Ring]{}
		return
	}
	r := new(Ring)
	p := r

	//# Changed the implementation to already form a cycle here so that we can use
	//# the memory predicate in the invariant and have an easier time establishing it in the end.
	r.next = r
	r.prev = r
	elems = set[*Ring]{r}
	fold r.Mem(elems, true)
	
	invariant r.Mem(elems, true)
	invariant len(elems) == i
	invariant p in elems
	invariant 1 <= i && i <= n
	decreases n - i
	for i := 1; i < n; i++ {
		//# Implementation was changed. Every iteration we take a consistent ring and return a consistent ring with a new element.
		unfold r.Mem(elems, true)
		q := &Ring{}
		//assume q != p
		q.prev = p
		q.next = p.next
		q.prev.next = q
		q.next.prev = q
		p = q
		elems = elems union set[*Ring]{p}
		//assert p.next != p
		//assert p.prev != p
		fold r.Mem(elems, true)
	}
	
	//p.next = r //# removed
	//r.prev = p //# removed 
	
	res = r
}*/


/*
// Link connects ring r with ring s such that r.Next()
// becomes s and returns the original value for r.Next().
// r must not be empty.
//
// If r and s point to the same ring, linking 
// them removes the elements between r and s from the ring.
// The removed elements form a subring and the result is a
// reference to that subring (if no elements were removed,
// the result is still the original value for r.Next(),
// and not nil).
//#"Pointing to the same ring" here means to elements of the same ring structure
//
// If r and s point to different rings, linking
// them creates a single ring with the elements of s inserted
// after r. The result points to the element following the
// last element of s after insertion.
//#This means likewise the result points to the original r.Next()
requires r != nil
requires r in elemsR
requires r.Mem(elemsR, true)
requires (s != nil && !(s in elemsR)) ==> (s.Mem(elemsS, true) && s in elemsS)
//ensures  (!(s in elemsR)) ==> (res == old(unfolding r.Mem(elemsR, true) in r.next && res.Mem((elemsR union elemsS), true)))
func (r *Ring) Link(s *Ring, ghost elemsR set[*Ring], ghost elemsS set[*Ring]) (res *Ring) {
	n := r.Next(elemsR, r, true)
	if s != nil {
		ghost elemsX := (s in elemsR)?(elemsR):(elemsS)
		ghost owner := (s in elemsR)?(r):(s)
		p := s.Prev(elemsX, owner, true)
		// Note: Cannot use multiple assignment because
		// evaluation order of LHS is not specified.
		unfold r.Mem(elemsR, true)
		ghost if !(s in elemsR){
			unfold s.Mem(elemsS, true)
		}
		r.next = s
		s.prev = r
		n.prev = p //# This only works due to the postcondition 'res in elems' in Next()
		p.next = n //# This only works due to the postcondition 'res in elems' in Prev()
		ghost if !(s in elemsR){
			fold n.Mem((elemsR union elemsS), true)
		}
		//ghost if (s in elemsR){
		//	ghost if r==s && len(elemsR)>1{
		//		fold n.Mem((elemsR setminus (set[*Ring]{r})), true)
		//	}
		//	//fold n.Mem((?????), true) //# elems needs to be all elements strictly between r and s, BUT WHAT IF r==s??
		//}
	}
	return n
}
*/

/*
// Unlink removes n % r.Len() elements from the ring r, starting
// at r.Next(). If n % r.Len() == 0, r remains unchanged.
// The result is the removed subring. r must not be empty.
func (r *Ring) Unlink(n int) *Ring {
	if n <= 0 {
		return nil
	}
	return r.Link(r.Move(n + 1))
}

// Len computes the number of elements in ring r.
// It executes in time proportional to the number of elements.
func (r *Ring) Len() int {
	n := 0
	if r != nil {
		n = 1
		for p := r.Next(); p != r; p = p.next {
			n++
		}
	}
	return n
}

// Do calls function f on each element of the ring, in forward order.
// The behavior of Do is undefined if f changes *r.
func (r *Ring) Do(f func(any)) {
	if r != nil {
		f(r.Value)
		for p := r.Next(); p != r; p = p.next {
			f(p.Value)
		}
	}
}
*/
