// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package ring implements operations on circular lists.

// +gobra
package ring

// A Ring is an element of a circular list, or ring.
// Rings do not have a beginning or end; a pointer to any ring element
// serves as reference to the entire ring. Empty rings are represented
// as nil Ring pointers. The zero value for a Ring is a one-element
// ring with a nil Value.
type Ring struct {
	next, prev *Ring
	Value      any // for use by client; untouched by this library
}


//# Will be properly documented and moved to a separate ring_spec.gobra file
pred (r *Ring) Mem(ghost s set[*Ring], ghost isInit bool) {
	r in s &&
	(forall i *Ring :: i in s ==> (acc(&i.next) && acc(&i.prev) && acc(&i.Value))) &&
	((r.next == nil || r.prev == nil) ==> !isInit) && //# More correctly, it is !isInit if it cannot reach itself in both directions via the same Ring elements
	(!isInit ==> ((s == set[*Ring]{r}) && (r.next == nil && r.prev == nil))) &&
	(isInit ==> (
		(len(s) == 1 ==> (r.next==r && r.prev==r)) &&
		(forall i *Ring :: i in s ==> (i.next != nil && i.prev != nil)) &&
		((len(s) > 1) ==> (forall i *Ring :: i in s ==> (i.next != i && i.prev != i))) &&
		(forall i, j *Ring :: ((i in s && i.next == j) ==> (j in s && j.prev == i && i.next.prev == i && j.prev.next == j))) &&
		(forall i, j *Ring :: ((i in s && i.prev == j) ==> (j in s && j.next == i && i.prev.next == i && j.next.prev == j)))))
}
//# enforce structure by:
//# forall elements, forall i in [0,len]: moveLeft(i) == moveRight(len-i)
//# problematic for Ring because we get Len() by the same logic

requires r.Mem(elems, isInit)
ensures  r.Mem(set[*Ring]{r}, true)
ensures  r == res
decreases
func (r *Ring) init(ghost elems set[*Ring], ghost isInit bool) (res *Ring) {
	unfold r.Mem(elems, isInit)
	r.next = r
	r.prev = r
	fold r.Mem(set[*Ring]{r}, true)
	return r
}


// Next returns the next ring element. r must not be empty.
//# We use 'owner' here to make calls from different receivers in the same ring structure work (see e.g. Link)
//requires r != nil
requires r in elems
requires owner.Mem(elems, isInit)
ensures  !isInit ==> (owner.Mem(set[*Ring]{r}, true) && res == r) //# The comment does not explain that r is returned if the ring is not initialized but that's what the implementation does.
ensures  isInit ==> (owner.Mem(elems, true) && res in elems)
ensures  isInit ==> res == r.NextPure(elems, owner)
decreases
func (r *Ring) Next(ghost elems set[*Ring], ghost owner *Ring, ghost isInit bool) (res *Ring) {
	unfold owner.Mem(elems, isInit)
	if r.next == nil {
		assert !isInit //# here we know !isInit
		fold owner.Mem(elems, false)
		return r.init(elems, false)
	}
	res = r.next
	fold owner.Mem(elems, true)
}

ghost
requires r in elems
requires owner.Mem(elems, true)
ensures  unfolding owner.Mem(elems, true) in res == r.next
ensures  unfolding owner.Mem(elems, true) in len(elems) > 1 ==> res != r //# This implication is already guaranteed by the predicate but this fact is needed explicitly in 'Link'
decreases
pure
func (r *Ring) NextPure(ghost elems set[*Ring], ghost owner *Ring) (res *Ring) {
	return unfolding owner.Mem(elems, true) in r.next
}

// Prev returns the previous ring element. r must not be empty.
//# We use 'owner' here to make calls from different receivers in the same ring structure work (see e.g. Link)
requires r != nil
requires r in elems
requires owner.Mem(elems, isInit)
ensures  !isInit ==> (owner.Mem(set[*Ring]{r}, true) && res == r) //# The comment does not explain that r is returned if the ring is not initialized but that's what the implementation does.
ensures  isInit ==> (owner.Mem(elems, true) && res in elems)
ensures  isInit ==> res == r.PrevPure(elems, owner)
decreases
func (r *Ring) Prev(ghost elems set[*Ring], ghost owner *Ring, ghost isInit bool) (res *Ring) {
	unfold owner.Mem(elems, isInit)
	if r.next == nil {
		assert !isInit //# here we know !isInit
		fold owner.Mem(elems, false)
		return r.init(elems, false)
	}
	res = r.prev
	fold owner.Mem(elems, true)
}

ghost
requires r in elems
requires owner.Mem(elems, true)
ensures  unfolding owner.Mem(elems, true) in res == r.prev
ensures  unfolding owner.Mem(elems, true) in len(elems) > 1 ==> res != r //# This implication is already guaranteed by the predicate but this fact is needed explicitly in 'Link'
decreases
pure
func (r *Ring) PrevPure(ghost elems set[*Ring], ghost owner *Ring) (res *Ring) {
	return unfolding owner.Mem(elems, true) in r.prev
}


ghost
requires owner.Mem(elems,true)
requires r in elems
requires n >= 0
ensures  n == 0 ==> res == r 
ensures  n > 0 ==> res == (unfolding owner.Mem(elems,true) in r.next.moveNext(n - 1, owner, elems)) 
decreases n
pure func (r *Ring) moveNext(n int, ghost owner *Ring, ghost elems set[*Ring]) (res * Ring){
	return unfolding owner.Mem(elems, true) in ((n == 0) ? r : r.next.moveNext(n - 1, owner, elems))
}

/*
//# TEST NEXT
requires r.Mem(elems,true)
requires r in elems
ensures  r.Mem(elems, true)
ensures  (res == r.moveNext(3, r, elems))
func (r *Ring) moveNextTest(ghost elems set[*Ring]) (res *Ring){
	unfold r.Mem(elems, true)
	res = r.next.next.next
	fold r.Mem(elems, true)
}
*/

ghost
requires owner.Mem(elems,true)
requires r in elems
requires n <= 0
ensures  n == 0 ==> res == r 
ensures  n < 0 ==> res == (unfolding owner.Mem(elems,true) in r.prev.movePrev(n + 1, owner, elems)) 
decreases 0 - n
pure func (r *Ring) movePrev(n int, ghost owner *Ring, ghost elems set[*Ring]) (res * Ring){
	return unfolding owner.Mem(elems, true) in ((n == 0) ? r : r.prev.movePrev(n + 1, owner, elems))
}

/*
//# TEST PREV
requires r.Mem(elems,true)
requires r in elems
ensures  r.Mem(elems, true)
ensures  (res == r.movePrev(-3, r, elems))
func (r *Ring) movePrevTest(ghost elems set[*Ring]) (res *Ring){
	unfold r.Mem(elems, true)
	res = r.prev.prev.prev
	fold r.Mem(elems, true)
}
*/



// Move moves n % r.Len() elements backward (n < 0) or forward (n >= 0)
// in the ring and returns that ring element. r must not be empty.
requires  r.Mem(elems, isInit) //# make this PRESERVES
requires  r != nil
requires  r in elems
ensures   !isInit ==> (r.Mem(set[*Ring]{r}, true) && res == old(r)) //# The comment does not explain that r is returned if the ring is not initialized but that's what the implementation does.
ensures   n == 0 ==> res == r
ensures   isInit ==> r.Mem(elems, true)
//ensures   (isInit && n > 0) ==> (res == r.moveNext(n, r, elems))
//ensures   (isInit && n < 0) ==> (res == r.movePrev(n, r, elems))
//# Why does the implementation not make the modulo calculation and save on potentially unnecessary iterations? --> We'd need to run Len() (Len() many iterations) but for n > 2*Len() it'd still always make sense to compute the modulus
func (r *Ring) Move(n int, ghost elems set[*Ring], ghost isInit bool) (res *Ring) {
	if unfolding r.Mem(elems, isInit) in r.next == nil {
		return r.init(elems, isInit)
		assert r.Mem(set[*Ring]{r}, true)
	}
	
    startRing := r  //# included for invariant
    startN := n     //# included for invariant
	switch {
	case n < 0:
		invariant startRing.Mem(elems, true)
		invariant r in elems
		invariant startN <= n && n <= 0
        //invariant startRing.movePrev((startN - n), startRing, elems) == r
		decreases 0 - n
		for ; n < 0; n++ {
			unfold startRing.Mem(elems, true)
			r = r.prev
			fold startRing.Mem(elems, true)
		}
	case n > 0:
		invariant startRing.Mem(elems, true)
		invariant r in elems
		invariant startN >= n && n >= 0
        //invariant startRing.moveNext((startN - n), owner, elems) == r
		decreases n
		for ; n > 0; n-- {
			unfold startRing.Mem(elems, true)
			r = r.next
			fold startRing.Mem(elems, true)
		}
	}
	return r
}



// New creates a ring of n elements.
ensures n <= 0 ==> res == nil
//ensures n > 0 ==> (len(elems) == n && res.Mem(elems, true))
func New(n int) (res *Ring, ghost elems set[*Ring]) {
	if n <= 0 {
		res = nil
		elems = set[*Ring]{}
		return
	}
	r := new(Ring)
	p := r
	ghost q := r //ghost dummy
	elems = set[*Ring]{r}

	invariant 1 <= i && i <= n
	invariant r in elems
	invariant p in elems
	invariant len(elems) == i
	invariant q in elems //ghost dummy
	invariant forall e *Ring :: e in elems ==> (acc(&e.next) && acc(&e.prev) && acc(&e.Value))

	invariant r != p ==> (q.next != nil && q.next == p) //ghost dummy

	invariant r != p ==> p.prev != nil
	invariant forall e *Ring :: e in elems ==> ((e != r && e != p) ==> (e.next != nil && e.prev != nil))
	invariant forall e1, e2 *Ring :: (e1 in elems && e1.next == e2 && e1 != p && e2 != r) ==> (e2 in elems && e2.prev == e1 && e1.next.prev == e1 && e2.prev.next == e2)
	//invariant forall e1, e2 *Ring :: (e1 in elems && e1.prev == e2 && e1 != r && e2 != p) ==> (e2 in elems && e2.next == e1 && e1.prev.next == e1 && e2.next.prev == e2)
	//invariant forall e1, e2 *Ring :: (e1 in elems && e1.prev == e2 && e1 != r && e2 != p) ==> (e2 in elems && e2.next == e1) //# Why does this not work?
	decreases n-i
	for i := 1; i < n; i++ {
		p.next = &Ring{prev: p}
		q = p //ghost dummy
		p = p.next
		assert !(p in elems)
		elems = elems union set[*Ring]{p}
		assert p.prev == q
		assert q.next == p
	}
	p.next = r
	r.prev = p
	return r
}

/*
// New creates a ring of n elements.
ensures n <= 0 ==> res == nil
ensures n > 0 ==> (len(elems) == n && res.Mem(elems, true))
func New(n int) (res *Ring, ghost elems set[*Ring]) {
	if n <= 0 {
		res = nil
		elems = set[*Ring]{}
		return
	}
	r := new(Ring)
	p := r

	//# Changed the implementation to already form a cycle here so that we can use
	//# the memory predicate in the invariant and have an easier time establishing it in the end.
	r.next = r
	r.prev = r
	elems = set[*Ring]{r}
	fold r.Mem(elems, true)
	
	invariant r.Mem(elems, true)
	invariant len(elems) == i
	invariant p in elems
	invariant 1 <= i && i <= n
	decreases n - i
	for i := 1; i < n; i++ {
		//# Implementation was changed. Every iteration we take a consistent ring and return a consistent ring with a new element.
		unfold r.Mem(elems, true)
		q := &Ring{}
		//assume q != p
		q.prev = p
		q.next = p.next
		q.prev.next = q
		q.next.prev = q
		p = q
		elems = elems union set[*Ring]{p}
		//assert p.next != p
		//assert p.prev != p
		fold r.Mem(elems, true)
	}
	
	//p.next = r //# removed
	//r.prev = p //# removed 
	
	res = r
}*/

requires r.Mem(elems, true)
requires r in elems //# contained within the predicate but required for the precondition of Next
func (r *Ring) problem(ghost elems set[*Ring]) (res *Ring) {
	n := r.Next(elems, r, true)
	assert n == r.NextPure(elems, r)
	//assert n == old(r.NextPure(elems, r))
}

// Link connects ring r with ring s such that r.Next()
// becomes s and returns the original value for r.Next().
// r must not be empty.
//
// If r and s point to the same ring, linking 
// them removes the elements between r and s from the ring.
// The removed elements form a subring and the result is a
// reference to that subring (if no elements were removed,
// the result is still the original value for r.Next(),
// and not nil).
//# "Pointing to the same ring" here means to elements of the same ring structure
//
// If r and s point to different rings, linking
// them creates a single ring with the elements of s inserted
// after r. The result points to the element following the
// last element of s after insertion.
//# This means likewise the result points to the original r.Next()
requires r != nil
requires r in elemsR
requires r.Mem(elemsR, true)
requires (s != nil && !(s in elemsR)) ==> (s.Mem(elemsS, true) && s in elemsS)
//ensures  (!(s in elemsR)) ==> (res == old(unfolding r.Mem(elemsR, true) in r.next) /*&& res.Mem((elemsR union elemsS), true)*/)
func (r *Ring) Link(s *Ring, ghost elemsR set[*Ring], ghost elemsS set[*Ring]) (res *Ring) {
	n := r.Next(elemsR, r, true)
	assert n == r.NextPure(elemsR, r)
	if s != nil {
		ghost elemsX := (s in elemsR)?(elemsR):(elemsS)
		ghost owner := (s in elemsR)?(r):(s)
		p := s.Prev(elemsX, owner, true)
		// Note: Cannot use multiple assignment because
		// evaluation order of LHS is not specified.
		unfold r.Mem(elemsR, true)
		ghost if !(s in elemsR){
			unfold s.Mem(elemsS, true)
		}

		assert r.next == n

		r.next = s
		s.prev = r
		n.prev = p //# This only works due to the postcondition 'res in elems' in Next()
		p.next = n //# This only works due to the postcondition 'res in elems' in Prev()
		ghost if !(s in elemsR){
			fold n.Mem((elemsR union elemsS), true)
		}
		ghost if (s in elemsR){
			ghost if r == s {
				ghost if len(elemsR) == 1 {
					assert r == n
					assert r == p
					assert r.next == r && r.prev == r
					//fold n.Mem(elemsR, true)
				}
				ghost if len(elemsR) > 1 {
					assert n != r
					assert p != r
					assert forall i *Ring :: i in (elemsR setminus (set[*Ring]{r})) ==> (i.next != nil && i.prev != nil)
					assert n.prev == p
					assert p.next == n
					assert forall i, j *Ring :: (i in (elemsR setminus (set[*Ring]{r})) && i.next == j) ==> (j in (elemsR setminus (set[*Ring]{r})) && j.prev == i) //# Already this does not work
					//assert forall i, j *Ring :: (i in (elemsR setminus (set[*Ring]{r})) && i.next == j) ==> (j in (elemsR setminus (set[*Ring]{r})) && j.prev == i && i.next.prev == i && j.prev.next == j)
					//assert forall i, j *Ring :: (i in (elemsR setminus (set[*Ring]{r})) && i.prev == j) ==> (j in (elemsR setminus (set[*Ring]{r})) && j.next == i && i.prev.next == i && j.next.prev == j)
					//fold n.Mem((elemsR setminus (set[*Ring]{r})), true)
				}
				
			}
			//fold n.Mem((?????), true) //# elems needs to be all elements strictly between r and s, BUT WHAT IF r==s??
		}
	}
	//assert n == old(r.NextPure(elemsR, r)) //# Why does this not work?
	return n
}


/*
// Unlink removes n % r.Len() elements from the ring r, starting
// at r.Next(). If n % r.Len() == 0, r remains unchanged.
// The result is the removed subring. r must not be empty.
func (r *Ring) Unlink(n int) *Ring {
	if n <= 0 {
		return nil
	}
	return r.Link(r.Move(n + 1))
}*/

// Len computes the number of elements in ring r.
// It executes in time proportional to the number of elements.
//# This method can be called on a ring r that is not yet properly initialize.
//# In that case the loop initialization will call r.Next(), return an initialized ring r and terminate while returning a length of 1.
requires r != nil ==> r.Mem(elems, isInit)
ensures  r == nil ==> res == 0
func (r *Ring) Len(ghost elems set[*Ring], ghost isInit bool) (res int) {
	n := 0
	if r != nil {
		n = 1
		ghost getsInit := false

		invariant n >= 1
		invariant isInit ==> r.Mem(elems, true) //# How do we talk about the predicate when !isInit? An invariant talks about what is true before and after every loop iteration but the predicate changes in the loop initialization.
		invariant !isInit ==> r.Mem(elems, getsInit) //# This attempt does not work because the loop initialization happens before the check for the invariant.
		invariant r in elems
		invariant !isInit ==> p == r
		decreases len(elems) - n
		for p, getsInit := r.Next(elems, r, isInit), true; p != r; p = p.next {
			n++
		}
	}
	return n
}

/*
// Do calls function f on each element of the ring, in forward order.
// The behavior of Do is undefined if f changes *r.
func (r *Ring) Do(f func(any)) {
	if r != nil {
		f(r.Value)
		for p := r.Next(); p != r; p = p.next {
			f(p.Value)
		}
	}
}
*/
