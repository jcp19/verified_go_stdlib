package bytes

// +gobra

import (
   . "verification/utils/definitions"
   b "verification/utils/bitwise"
   sl "verification/utils/slices"
   seqs "verification/utils/seqs"
   sets "verification/utils/sets"
   . "bytes/spec"
)


// Repeat


// bp == a
// i == b
// bp == len(b) * i
// bp*2 == len(b) * i*2
// a2 == len(b) * b2
ghost
requires a * 2 == a2
requires b * 2 == b2
requires b * 2 == b2
requires a == c * b
ensures a2 == c * b2
decreases
func lemmaMul2Inj(a, b, a2, b2, c int) {

}

ghost
requires a == b
requires b == c
ensures a == c
decreases
func lemmaEqTransitive_seq(a, b, c seq[byte]) {

}

ghost
ensures SpecRepeat(b, 1) == b
decreases
func lemmaSpecRepeat_1(b seq[byte]) {
	assert SpecRepeat(b, 1) == b ++ SpecRepeat(b, 0)
}

ghost
requires n >= 0
ensures SpecRepeat(b, 2 * n) == SpecRepeat(b, n) ++ SpecRepeat(b, n)
decreases _
func lemmaSpecRepeat_2n(b seq[byte], n int) {
	if n != 0 {
		assert SpecRepeat(b, n) == b ++ SpecRepeat(b, n - 1)
		assert SpecRepeat(b, n) ++ SpecRepeat(b, n) == b ++ SpecRepeat(b, n - 1) ++ b ++ SpecRepeat(b, n - 1)
		// order of repeating doesn't matter because it's always the same element that is repeated
		assume b ++ SpecRepeat(b, n - 1) ++ b ++ SpecRepeat(b, n - 1) == b ++ b ++ SpecRepeat(b, n - 1) ++ SpecRepeat(b, n - 1)
		lemmaSpecRepeat_2n(b, n - 1)
		assert SpecRepeat(b, n - 1) ++ SpecRepeat(b, n - 1) == SpecRepeat(b, 2 * (n - 1))
		assert SpecRepeat(b, 2 * n - 1) == b ++ SpecRepeat(b, n - 1) ++ SpecRepeat(b, n - 1)
		assert SpecRepeat(b, 2 * n) == b ++ b ++ SpecRepeat(b, n - 1) ++ SpecRepeat(b, n - 1)
	} else {
		TODO()
	}
}

// Count

ghost
requires s[i:i+len(sep)] == sep
ensures InRangeInc(i, 0, len(s) - len(sep))
decreases
func lemmaCountCanView(s seq[byte], sep seq[byte], i int) {
	TODO()
}

ghost
requires InRangeInc(idx, 0, len(s))
requires forall j int :: { j in indices }{ s[j:j+len(sep)] } !(j in indices) ==> !(InRangeInc(j, 0, idx - len(sep))) || s[j:j+len(sep)] != sep || SetContainsInRange(indices, j-len(sep), j)
requires forall j int :: {s[idx:][j:j+len(sep)]} InRangeInc(j, 0, len(s[idx:]) - len(sep)) ==> s[idx:][j:j+len(sep)] != sep
ensures forall j int :: { j in indices }{ s[j:j+len(sep)] } !(j in indices) ==> ( !InRangeInc(j, 0, len(s) - len(sep)) || s[j:j+len(sep)] != sep || SetContainsInRange(indices, j-len(sep), j))
decreases
func lemmaCountAux(s, sep seq[byte], indices set[int], idx int) {
	assume forall j int :: {s[j:j+len(sep)]} InRangeInc(j, idx, len(s) - len(sep)) ==> s[j:j+len(sep)] != sep
	assert forall j int :: { j in indices }{ s[j:j+len(sep)] } !(j in indices) && InRangeInc(j, 0, idx - len(sep)) && !SetContainsInRange(indices, j-len(sep), j) ==> s[j:j+len(sep)] != sep
	assert forall j int :: { j in indices }{ s[j:j+len(sep)] } !(j in indices) && InRangeInc(j, idx, len(s) - len(sep)) && !SetContainsInRange(indices, j-len(sep), j) ==> s[j:j+len(sep)] != sep
	assume forall j int :: { j in indices }{ s[j:j+len(sep)] } !(j in indices) && InRangeInc(j, 0, len(s) - len(sep)) && !SetContainsInRange(indices, j-len(sep), j) ==> s[j:j+len(sep)] != sep
}

ghost
requires 0 < p
requires acc(sl.Bytes(a, 0, len(a)), p)
requires acc(sl.Bytes(b, 0, len(b)), p)
requires r == ((unfolding acc(sl.Bytes(a, 0, len(a)), p) in string(a)) == (unfolding acc(sl.Bytes(b, 0, len(b)), p) in string(b)))
ensures acc(sl.Bytes(a, 0, len(a)), p)
ensures acc(sl.Bytes(b, 0, len(b)), p)
ensures r == (View(a) == View(b))
decreases
func stringEqualsImplViewEquals(r bool, a, b []byte, p perm)
